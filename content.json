{"meta":{"title":"yuanZzz's Blog","subtitle":null,"description":null,"author":"Zzz","url":"http://yuanzzi.github.io","root":"/"},"pages":[{"title":"关于/留言","date":"2019-09-20T19:40:38.614Z","updated":"2019-09-20T19:40:38.614Z","comments":true,"path":"about/index.html","permalink":"http://yuanzzi.github.io/about/index.html","excerpt":"","text":"坐标广州，一名正在工作学习的…（日后补上可以在本页留下你想说的话。","author":{"name":"Zzz"}},{"title":"所有分类","date":"2019-09-19T13:05:43.764Z","updated":"2019-09-19T13:05:43.764Z","comments":true,"path":"categories/index.html","permalink":"http://yuanzzi.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-20T19:34:44.888Z","updated":"2019-09-20T19:34:44.888Z","comments":true,"path":"friends/index.html","permalink":"http://yuanzzi.github.io/friends/index.html","excerpt":"","text":"欢迎申请友链"},{"title":"所有标签","date":"2019-09-19T13:05:43.765Z","updated":"2019-09-19T13:05:43.765Z","comments":true,"path":"tags/index.html","permalink":"http://yuanzzi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"欢迎来到 yuanZzz 的个人博客","slug":"welcome","date":"2019-09-19T13:05:43.763Z","updated":"2019-09-20T19:22:52.516Z","comments":true,"path":"2019/09/19/welcome/","link":"","permalink":"http://yuanzzi.github.io/2019/09/19/welcome/","excerpt":"我们所度过的每个平凡的日常,也许就是连续发生的奇迹。日々私たちが过ごしている日常は、実は、奇迹の连続なのかもしれな。 ——《日常》","text":"我们所度过的每个平凡的日常,也许就是连续发生的奇迹。日々私たちが过ごしている日常は、実は、奇迹の连続なのかもしれな。 ——《日常》 Welcome to my Blog !本博客为记录工作学习的个人博客","categories":[],"tags":[]},{"title":"JAVA 捕获唯一索引重复异常","slug":"ViolateExcept","date":"2019-07-27T16:00:00.000Z","updated":"2019-09-19T13:05:43.761Z","comments":true,"path":"2019/07/28/ViolateExcept/","link":"","permalink":"http://yuanzzi.github.io/2019/07/28/ViolateExcept/","excerpt":"JAVA 捕获 MySQLIntegrityConstraintViolationException （唯一索引重复）异常","text":"JAVA 捕获 MySQLIntegrityConstraintViolationException （唯一索引重复）异常 在 service 层的数据库操作块无法捕捉因唯一索引而引发的数据库更新或插入异常，只能通过service方法抛出 DataAccess 异常，再到 Controller 层捕获 1234567891011121314public Object update(UserEntity user) throws DataAccessException&#123; ...&#125;@RequestMapping(\"/update\")@ResponseBodypublic Object update(@RequestBody userEntity)&#123; try&#123; return userService.update(userEntity); &#125;catch(DataAccessException e)&#123; return FunCommon.getReturnJson(\"msg\",\"用户名重复\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yuanzzi.github.io/categories/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yuanzzi.github.io/tags/MyBatis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yuanzzi.github.io/tags/MySQL/"}]},{"title":"BAT 脚本实现文件夹监控","slug":"batWatchfile","date":"2019-07-12T16:00:00.000Z","updated":"2019-09-19T13:05:43.762Z","comments":true,"path":"2019/07/13/batWatchfile/","link":"","permalink":"http://yuanzzi.github.io/2019/07/13/batWatchfile/","excerpt":"Windows 环境下快速编写 BAT 脚本实现文件夹监控","text":"Windows 环境下快速编写 BAT 脚本实现文件夹监控 bat 脚本监控 windows 文件夹，如有新增文件，则调用另外一个bat脚本，再删除文件 123456789101112131415161718192021222324252627282930@echo off &amp; title 监控文件夹 By 放射云color 0a &amp; mode 35,3 ::设置要监控的文件夹set MtrDir=C:\\Users\\Administrator\\Desktop\\xp\\aaa ::设置要调用的bat脚本set Bat=alert.bat echo 正在初始化记录文件 ...(for /f \"delims=\" %%a in ('dir /a-d/s/b \"%MtrDir%\\*\"') do ( echo \"%%~a\"))&gt;\"%tmp%\\oFiles.Lst\":Loopset \"Change=\"cls &amp; echo 正在监控文件夹中 ...for /f \"delims=\" %%a in ('dir /a-d/s/b \"%MtrDir%\"') do ( findstr /i \"^\\\"%%~a\\\"$\" \"%tmp%\\oFiles.Lst\" &gt;nul || ( echo del /f /q \"%%~a\"&gt;&gt;\"%tmp%\\DelNewFile.bat\" set Change=1 ))if defined Change ( echo 发现新增文件，启动其它脚本。 call \"%Bat%\" call \"%tmp%\\DelNewFile.bat\")goto Loop","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yuanzzi.github.io/categories/笔记/"}],"tags":[{"name":".bat","slug":"bat","permalink":"http://yuanzzi.github.io/tags/bat/"},{"name":"Windows","slug":"Windows","permalink":"http://yuanzzi.github.io/tags/Windows/"}]},{"title":"Spring 项目实现简单的多线程定时同步任务","slug":"timerSycn","date":"2019-02-26T06:31:31.000Z","updated":"2019-09-19T13:05:43.763Z","comments":true,"path":"2019/02/26/timerSycn/","link":"","permalink":"http://yuanzzi.github.io/2019/02/26/timerSycn/","excerpt":"Spring 项目实现简单的多线程定时同步任务","text":"Spring 项目实现简单的多线程定时同步任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//1 在contextListener 直接定义调用3个线程public class ContextListener implements ServletContextListener&#123;@Overridepublic void contextInitialized(ServleteContextEvent sce )&#123; Thread t1 = new Thread(new Runnable()&#123; @Override public void run()&#123; try&#123; while(true)&#123; com.test.ApplySynManager.getInstance().synMain(); Thread.sleep(60 * 1000); &#125; &#125;catch()&#123; e.printStackTrace(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable()&#123; ... &#125;); Thread t3 = new Thread(new Runnable()&#123; @Override public void run()&#123; ... &#125;); t1.start(); t2.start(); t3.start();&#125;//2、单例模式管理线程public class ApplySynManager&#123; private ApplySynManager()&#123;&#125; private ApplySynManager examApp = null; //单例模式，保持这个对象 public static ApplySynManager getInstance()&#123; if (examApp == null) &#123; //当flag == true时，为了解决，timer.cancel()后，重新创建一个timer examApp = new ExamApplySynManager(); &#125; return examApp; &#125; public void synMain()&#123; if(DefCommon.syncExamThread == DefCommon.THREAD_RUNING)&#123; FunCommon.printLog(\"线程运行中synExamMain\"); return FunCommon.getReturnJson(DefCommon.E_Fail,\"syncExamThread,线程运行中\"); &#125; DefCommon.syncExamThread = DefCommon.THREAD_RUNING; //业务处理... //线程标记为结束 DefCommon.syncExamThread = DefCommon.THREAD_STOP; return; &#125; public void synReport()&#123; ... //对应t2 &#125; public void synDcm()&#123; ... //对应t3 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yuanzzi.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yuanzzi.github.io/tags/Spring/"}]},{"title":"原生 Ajax 上传文件","slug":"ajaxUpload","date":"2019-02-12T08:18:07.000Z","updated":"2019-09-19T13:05:43.761Z","comments":true,"path":"2019/02/12/ajaxUpload/","link":"","permalink":"http://yuanzzi.github.io/2019/02/12/ajaxUpload/","excerpt":"有时小小的文件上传用 WebUploader 之类嫌费劲，看下原生 Ajax 上传文件","text":"有时小小的文件上传用 WebUploader 之类嫌费劲，看下原生 Ajax 上传文件 值得注意的一点是要在 input[type=file] Dom上添加 Listenner(change) 事件，否则会点击就直接提交 ajax 请求了 123&lt;form enctype=\"multipart/form-data\" method=\"POST\"&gt; &lt;input type=\"file\" id=\"imgCase\" onclick=\"javascrpit:this.addEventListener('change', upload, false);\" multiple=\"true\" /&gt;&lt;/form&gt; 12345678910111213141516171819202122 function upload()&#123; var formData = new FormData(); for(var i=0;i&lt;$('#imgCase')[0].files.length;i++)&#123; formData.append('file['+i+']',$('#imgCase')[0].files[i]); &#125; $.ajax(&#123; type:\"post\", url:serverURL+\"/attached/upl_atc\", data:formData, async:true, contentType:false, processData:false, mimeType:'mutipart/form-data', success:function(data)&#123; console.log(data); &#125; &#125;); &#125;补充：ajax 提交 form 表单会出现表单自动提交并跳转，需要添加onsubmit=\"return false\" &lt;form onsubmit=\"return false\" method=\"post\" action=\"#\"&gt;&lt;/form&gt;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://yuanzzi.github.io/categories/Web前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yuanzzi.github.io/tags/JQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yuanzzi.github.io/tags/Ajax/"}]},{"title":"两个非常实用的匹配中文字符正则表达式","slug":"regCN","date":"2018-11-30T16:00:00.000Z","updated":"2019-09-19T13:05:43.762Z","comments":true,"path":"2018/12/01/regCN/","link":"","permalink":"http://yuanzzi.github.io/2018/12/01/regCN/","excerpt":"在处理字符串时，特别是处理 HTML 字符串时，常常需要用到正则表达式来处理中文字符。 以下介绍两个非常实用的表达式","text":"在处理字符串时，特别是处理 HTML 字符串时，常常需要用到正则表达式来处理中文字符。 以下介绍两个非常实用的表达式 &gt; 由网络爬虫展开1. 仅仅匹配中文字符：([\\u4e00-\\u9fa5]+)12345678910111213141516String str = \"&lt;img alt=\\\"甲状腺。\\\" src= 'd://a.img' &gt; &lt;p&gt;这是第一句话！&lt;/p&gt;\";String reg = \"([\\\\u4e00-\\\\u9fa5]+)\";//String reg = \"([^\\\\x00-\\\\xff]+)\";Pattern pattern = Pattern.compile(reg);Matcher matcher = pattern.matcher(str);while(matcher.find())&#123; System.out.println(matcher.group(0)); &#125;//打印结果：甲状腺这是第一句话 2. 匹配中文字符以及标点：([^\\x00-\\xff]+)此表达式又称为双字节字符匹配 123456789101112131415String str = \"&lt;img alt=\\\"甲状腺。\\\" src= 'd://a.img' &gt; &lt;p&gt;这是第一句话！&lt;/p&gt;\";//String reg = \"([\\\\u4e00-\\\\u9fa5]+)\";String reg = \"([^\\\\x00-\\\\xff]+)\";Pattern pattern = Pattern.compile(reg);Matcher matcher = pattern.matcher(str);while(matcher.find())&#123; System.out.println(matcher.group(0)); &#125;//打印结果：甲状腺。这是第一句话！","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yuanzzi.github.io/categories/笔记/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yuanzzi.github.io/tags/正则/"},{"name":"字符串处理","slug":"字符串处理","permalink":"http://yuanzzi.github.io/tags/字符串处理/"}]},{"title":"Ajax 同步状态下获取返回值","slug":"synGetReurn","date":"2018-11-30T16:00:00.000Z","updated":"2019-09-19T13:05:43.763Z","comments":true,"path":"2018/12/01/synGetReurn/","link":"","permalink":"http://yuanzzi.github.io/2018/12/01/synGetReurn/","excerpt":"实际上 ajax 同步状态下是不可能获取到返回值的，只能利用回调方式在ajax方法外操作返回的数据","text":"实际上 ajax 同步状态下是不可能获取到返回值的，只能利用回调方式在ajax方法外操作返回的数据 12345678910111213141516171819202122function load_val(callback)&#123;//定义一个回调函数 $.getJSON('test.php' , function(dat)&#123; callback(data);//将返回结果当作参数返回 &#125;);&#125;load_val(function(data)&#123; alert(data);//这里可以得到值&#125;);function search(arg0,callback)&#123; $.ajax(&#123; url:, data:&#123;json:arg0&#125;, dataType:\"json\" async:true, success:function(data)&#123; callback(data); &#125; &#125;);&#125;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://yuanzzi.github.io/categories/Web前端/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yuanzzi.github.io/tags/Ajax/"}]},{"title":"CSS 实现“小三角”","slug":"tri","date":"2018-11-21T16:00:00.000Z","updated":"2019-09-19T13:05:43.763Z","comments":true,"path":"2018/11/22/tri/","link":"","permalink":"http://yuanzzi.github.io/2018/11/22/tri/","excerpt":"html 页面常常需要画小三角。如下代码，调整宽高和方向。","text":"html 页面常常需要画小三角。如下代码，调整宽高和方向。 &gt; 项目小结1234567891011&lt;style type=&quot;text/css&quot;&gt; .triangle&#123; width: 0px; height: 0px; border-width: 20px 12px; border-style: solid; border-color: transparent transparent #22364d transparent; &#125;&lt;/style&gt;&lt;div class=&quot;triangle&quot; id=&quot;doc_tri&quot;&gt;&lt;/div&gt; .triangle{ width: 0px; height: 0px; border-width: 20px 12px; border-style: solid; border-color: transparent transparent #169fe6 transparent; }","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://yuanzzi.github.io/categories/Web前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yuanzzi.github.io/tags/css/"}]},{"title":"BootStrap 下拉菜单组件关闭点击事件 ( 转换为鼠标悬停事件 )","slug":"drop","date":"2018-11-19T16:00:00.000Z","updated":"2019-09-19T13:05:43.762Z","comments":true,"path":"2018/11/20/drop/","link":"","permalink":"http://yuanzzi.github.io/2018/11/20/drop/","excerpt":"有些时候需要关闭 BootStrap 下拉按钮组件的点击弹出菜单事件 $(document).off(&#39;click.bs.dropdown.data-api&#39;)","text":"有些时候需要关闭 BootStrap 下拉按钮组件的点击弹出菜单事件 $(document).off(&#39;click.bs.dropdown.data-api&#39;) 由官网项目小结 友情链接 中华放射学分会 中华放射学杂志 放射学实践杂志 中国医学影像技术 万方数据库 CNKI 丁香园","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://yuanzzi.github.io/categories/Web前端/"}],"tags":[{"name":"BootStrap","slug":"BootStrap","permalink":"http://yuanzzi.github.io/tags/BootStrap/"}]},{"title":"Java 实现 HTTP 请求的三种方式","slug":"article","date":"2018-11-12T16:00:00.000Z","updated":"2019-09-19T13:05:43.761Z","comments":true,"path":"2018/11/13/article/","link":"","permalink":"http://yuanzzi.github.io/2018/11/13/article/","excerpt":"HttpURLConnection 是 JAVA 最原生的HTTP请求类。HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包。","text":"HttpURLConnection 是 JAVA 最原生的HTTP请求类。HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包。 &gt; 由JAVA网络爬虫延伸开1. HttpURLConnectionHttpURLConnection 是 JAVA 最原生的HTTP请求类。HttpURLConnection 的 connect() 函数，实际上只是建立了一个服务器的 tcp 连接,并没有实际发送http请求。 无论是用 post 还是 get , http 请求实际上直到 HttpURLConnection 的 getInputStream() 这个函数里面才正式发送出去。 &emsp;&emsp;在用 Post 方式发送请求时， URL 请求参数的设定顺序是重中之重，对 connection 对象的一切配置(那一堆set函数) 都必须在函数 connect() 执行之前完成。OutputStream的写操作， 必须在InputStream 的读操作之前。 123456789101112131415161718192021222324252627// 创建远程url连接对象URL url = new URL(httpurl);// 通过远程url连接对象打开一个连接，强转成httpURLConnection类connection = (HttpURLConnection) url.openConnection();// 设置连接方式：getconnection.setRequestMethod(\"GET\");// 设置连接主机服务器的超时时间：15000毫秒connection.setConnectTimeout(15000);// 设置读取远程返回的数据时间：60000毫秒connection.setReadTimeout(60000);// 发送请求connection.connect();// 通过connection连接，获取输入流if (connection.getResponseCode() == 200) &#123; is = connection.getInputStream(); // 封装输入流is，并指定字符集 br = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); // 存放数据 StringBuffer sbf = new StringBuffer(); String temp = null; while ((temp = br.readLine()) != null) &#123; sbf.append(temp); sbf.append(\"\\r\\n\"); &#125; result = sbf.toString();&#125; 2. HttpClientHttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 HTMLUnit 都使用了 HttpClient。 以下代码截取于自写爬虫之发送请求类 1234567891011121314151617HttpClient httpClient = new HttpClient();// 设置 HTTP 连接超时 5shttpClient.getHttpConnectionManager().getParams().setConnectionTimeout(5000);// 生成 GetMethod 对象并设置参数GetMethod getMethod = new GetMethod(url);// 设置 get 请求超时 5sgetMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT, 5000);// 设置请求重试处理getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler(5,true));// 执行 HTTP GET 请求// 4.处理 HTTP 响应内容// byte[] responseBody = getMethod.getResponseBody();// 读取为字节 数组 String contentType = getMethod.getResponseHeader(\"Content-Type\").getValue(); // 得到当前返回类型byte[] responseBody = toByteArray( getMethod.getResponseBodyAsStream());// 读取为字节 数组 3. CloseableHttpClient&emsp;&emsp;CloseableHttpClient 是 HttpClient 的帮助类 ( CloseableHttpClient 继承了 HttpClient 接口 ) 以下代码截取于自写爬虫之发送请求类 1234567891011121314151617181920// 设置连接超时时间 RequestConfig defaultRequestConfig = RequestConfig.custom() .setSocketTimeout(5000) .setConnectTimeout(5000) .setConnectionRequestTimeout(5000) .build(); // 生成CloseableHttpClient对象 //CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpClient httpclient = HttpClients.custom() .setDefaultRequestConfig(defaultRequestConfig) .build(); CloseableHttpResponse response = null; HttpGet httpGet = new HttpGet(url);httpGet.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0\");String contentType = entity.getContentType().getValue();// 得到当前返回类型response = httpclient.execute(httpGet);//获取响应HttpEntity entity = response.getEntity();","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yuanzzi.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yuanzzi.github.io/tags/Java/"},{"name":"Http","slug":"Http","permalink":"http://yuanzzi.github.io/tags/Http/"}]}]}